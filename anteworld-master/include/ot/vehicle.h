#pragma once

#ifndef __INTERGEN_GENERATED__vehicle_H__
#define __INTERGEN_GENERATED__vehicle_H__

//@file Interface file for vehicle interface generated by intergen
//See LICENSE file for copyright and license information

//host class: ::ground_vehicle

#include <comm/commexception.h>
#include <comm/intergen/ifc.h>
#include "object.h"
#include <ot/object.h>
#include <ot/vehicle_cfg.h>
#include <ot/explosion_params.h>
#include <ot/weapon_cfg.h>
#include <ot/geomob.h>
#include <ot/sndgrp.h>

class btRigidBody;

#include "vehicle_physics.h"

class ground_vehicle;


namespace ot {

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
/// VEHICLE CONTROL
////////////////////////////////////////////////////////////////////////////
class vehicle
    : public ot::object
{
public:

    // --- interface methods ---

    ot::EObjectType type() const;

    //@return unique object id
    uint id() const;

    void* get_custom_data() const;

    void set_custom_data( void* p );

    uint get_editor_id() const;

    void set_editor_id( uint id );

    ///Set collision group and mask
    void set_collision_group( uint group, uint mask );

    ///Get collision group and mask
    //@param mask optional mask value
    //@return collision group id
    uint get_collision_group( ifc_out uint* mask ) const;

    void* get_pkg_geomob() const;

    coid::token get_objurl() const;

    
    bool get_objdef_info( ifc_out ot::pkginfo::objdef& info ) const;

    const ot::vehicle_params& vehicle_params() const;

    const double3& get_pos() const;

    void set_pos( const double3& pos, bool commit = true );

    const quat& get_rot() const;

    void set_rot( const quat& rot );

    ///Set position and rotation
    void set_pos_rot( const double3& pos, const quat& rot );

    ///Get full positional data (with velocities)
    //@return 0 if object not ready (no data returned), >0 if ready and active, <0 if sleeping
    int get_positional_data( ot::dynamic_pos& data ) const;

    ///Set full positional data (with velocities)
    //@return 0 if object not ready and the position could not be set, else ok
    int set_positional_data( const ot::dynamic_pos& data );

    ///Update object in cache, change to permanent if necessary
    void commit();

    ///Set FPS camera model-space offset and initial rotation
    //@param pos offset position, relative to the object or bone
    //@param rot rotation from default camera orientation (model -z forward, +y up)
    //@param head_sim true if head movement should be simulated
    //@param cam_enabled true if camera rotation controls are enabled
    //@param joint_id bone id to attach to
    void set_fps_camera( const float3& pos, const quat& rot, bool head_sim = true, bool cam_enabled = true, uint joint_id = UMAX32 );

    float3 get_fps_camera_pos() const;

    ///Get heading/pitch/roll angles of the object in radians
    float3 heading_pitch_roll() const;

    ///Get current velocity in world space
    //@param model_space true for model-space velocity vector, false for world-space
    //@param linear linear velocity components [m/s] in selected space
    //@param angular angular velocity components [rad/s] in selected space
    void velocity( bool model_space, ifc_out float3& linear, ifc_out float3& angular ) const;

    //@param id 0 the main body
    iref<ot::geomob> get_geomob( int id );

    void start_engine();

    void stop_engine();

    ///Enter the vehicle with preferred camera mode
    //@return currently bound camera (after entering), negative values for seats
    //@param camode desired camera mode or seat id (negative)
    //@param bindio input mode
    ot::ECameraMode enter( ot::ECameraMode camode = ot::CamPrevious, ot::EControlsBinding bindio = ot::BindControls );

    ///Return camera control to UFO controller
    void exit();

    //@return current camera mode or seat (negative values), or ot::CamFree if camera isn't bound to this object
    ot::ECameraMode get_camera_mode() const;

    ///Fetch input controls data captured when vehicle was entered with ot::BindCapture
    //@param buf captured input controls data
    //@param append true if data should be appended into the buffer, false for swap/set
    //@note performs a buffer swap with internal controls buffer, keep using the same buffer to avoid unnecessary allocations
    void fetch_controls( ifc_out coid::dynarray<int32>& buf, bool append );

    ///Apply input controls data
    //@param cmd input command array pointer returned from fetch_controls
    //@param ncmds number of commands in the array
    void apply_controls( const int32* cmd, uint ncmds );

    ///Apply extra force
    //@param mpos model-space postion to act on
    //@param force model or world-space force vector
    //@param worldspace true for world-space, false for model-space force vector
    void extra_force( const float3& mpos, const float3& force, bool worldspace = false );

    ///Apply extra force impulse (force * dt)
    //@param mpos model-space postion to act on
    //@param impulse model or world-space force impulse vector
    //@param worldspace true for world-space, false for model-space force vector
    void extra_impulse( const float3& mpos, const float3& impulse, bool worldspace = false );

    //@return current offset from model pivot to center of mass
    float3 com_offset() const;

    //@return the underlying physics rigid body object, if any (cast to btRigidBody*)
    btCollisionObject* collision_object() const;

    ///Get run-time wheel data
    void get_wheels_data( ifc_out coid::dynarray<ot::wheel_data>& wda ) const;

    ///Get run-time wheel data
    void set_wheels_data( const coid::dynarray<ot::wheel_data>& wda );

    ///Pause/unpause simulation
    void pause( bool p );

    ///Insert an open door command
    //@param openid id of the openable part (script specific)
    //@param modifiers keyboard modifiers (LSHIFT=1, RSHIFT=2, LCTRL=4, RCTRL=8)
    void open( int openid, ushort modifiers );

    ///Remove from the scene
    void remove_from_scene();

    /// show/hide whole geom object
    void set_visible( bool visible );

    //@return true if the object is visible
    bool is_visible() const;

    //@return true if the geom is fully loaded
    bool is_ready() const;

    //@return true if the object is persistent in the world
    bool is_persistent() const;

    //@return true if script loading failed and vehicle can't get into the ready state
    bool is_script_error() const;

    void set_inputs( float engine, float brake, float steering, float parking_brake );

    ///Invoke ext_param script method with name and value arguments
    //@return true if ext_param script event exists
    bool set_ext_param( const coid::token& name, float value );

    ///Invoke ext_param script method with name, querying the value
    //@return true if ext_param script event exists
    bool get_ext_param( const coid::token& name, ifc_out float& value );

    iref<ot::vehicle_physics> physics_interface() const;

    // --- creators ---

    static iref<vehicle> _get_control_ifc( void* p ) {
        return _get_control_ifc<vehicle>(0, p);
    }

    template<class T>
    static iref<T> _get_control_ifc( T* _subclass_, void* p );

    ///Instantiate a new aircraft object
    //@param objpath path to objdef within packages
    static iref<vehicle> create( const coid::token& objpath, const double3& pos, const quat& rot ) {
        return create<vehicle>(0, objpath, pos, rot);
    }

    template<class T>
    static iref<T> create( T* _subclass_, const coid::token& objpath, const double3& pos, const quat& rot );

    // --- internal helpers ---

    ///Interface revision hash
    static const int HASHID = 1641788462;

    ///Interface name (full ns::class string)
    static const coid::tokenhash& IFCNAME() {
        static const coid::tokenhash _name = "ot::vehicle";
        return _name;
    }

    int intergen_hash_id() const override final { return HASHID; }

    bool iface_is_derived( int hash ) const override final {
        return hash == HASHID || ot::object::iface_is_derived(hash);
    }

    const coid::tokenhash& intergen_interface_name() const override final {
        return IFCNAME();
    }

    static const coid::token& intergen_default_creator_static( EBackend bck ) {
        static const coid::token _dc("");
        static const coid::token _djs("ot::vehicle@wrapper.js");
        static const coid::token _djsc("ot::vehicle@wrapper.jsc");
        static const coid::token _dlua("ot::vehicle@wrapper.lua");
        static const coid::token _dnone;

        switch(bck) {
        case IFC_BACKEND_CXX: return _dc;
        case IFC_BACKEND_JS:  return _djs;
        case IFC_BACKEND_JSC:  return _djsc;
        case IFC_BACKEND_LUA: return _dlua;
        default: return _dnone;
        }
    }

    //@return cached active interface of given host class
    //@note host side helper
    static iref<vehicle> intergen_active_interface(::ground_vehicle* host);

    template<enum EBackend B>
    static void* intergen_wrapper_cache() {
        static void* _cached_wrapper=0;
        if (!_cached_wrapper) {
            const coid::token& tok = intergen_default_creator_static(B);
            _cached_wrapper = coid::interface_register::get_interface_creator(tok);
        }
        return _cached_wrapper;
    }

    void* intergen_wrapper( EBackend bck ) const override final {
        switch(bck) {
        case IFC_BACKEND_JS: return intergen_wrapper_cache<IFC_BACKEND_JS>();
        case IFC_BACKEND_JSC: return intergen_wrapper_cache<IFC_BACKEND_JSC>();
        case IFC_BACKEND_LUA: return intergen_wrapper_cache<IFC_BACKEND_LUA>();
        default: return 0;
        }
    }

    EBackend intergen_backend() const override { return IFC_BACKEND_CXX; }

    const coid::token& intergen_default_creator( EBackend bck ) const override final {
        return intergen_default_creator_static(bck);
    }

    ///Client registrator
    template<class C>
    static int register_client()
    {
        static_assert(std::is_base_of<vehicle, C>::value, "not a base class");

        typedef iref<intergen_interface> (*fn_client)(void*, intergen_interface*);
        fn_client cc = [](void*, intergen_interface*) -> iref<intergen_interface> { return new C; };

        coid::token type = typeid(C).name();
        type.consume("class ");
        type.consume("struct ");

        coid::charstr tmp = "ot::vehicle";
        tmp << "@client-1641788462" << '.' << type;

        coid::interface_register::register_interface_creator(tmp, cc);
        return 0;
    }

protected:

    static coid::comm_mutex& share_lock() {
        static coid::comm_mutex _mx(500, false);
        return _mx;
    }

    typedef void (*cleanup_fn)(vehicle*, intergen_interface*);
    cleanup_fn _cleaner;

    ~vehicle() {
        VT_CALL(void,(),0)();
        if (_cleaner)
            _cleaner(this, 0);
    }

    vehicle() : _cleaner(0)
    {}
};

////////////////////////////////////////////////////////////////////////////////
template<class T>
inline iref<T> vehicle::_get_control_ifc( T* _subclass_, void* p )
{
    typedef iref<T> (*fn_creator)(vehicle*, void*);

    static fn_creator create = 0;
    static const coid::token ifckey = "ot::vehicle._get_control_ifc@1641788462";

    if (!create)
        create = reinterpret_cast<fn_creator>(
            coid::interface_register::get_interface_creator(ifckey));

    if (!create) {
        log_mismatch("_get_control_ifc", "ot::vehicle._get_control_ifc", "@1641788462");
        return 0;
    }

    return create(_subclass_, p);
}

////////////////////////////////////////////////////////////////////////////////
template<class T>
inline iref<T> vehicle::create( T* _subclass_, const coid::token& objpath, const double3& pos, const quat& rot )
{
    typedef iref<T> (*fn_creator)(vehicle*, const coid::token&, const double3&, const quat&);

    static fn_creator create = 0;
    static const coid::token ifckey = "ot::vehicle.create@1641788462";

    if (!create)
        create = reinterpret_cast<fn_creator>(
            coid::interface_register::get_interface_creator(ifckey));

    if (!create) {
        log_mismatch("create", "ot::vehicle.create", "@1641788462");
        return 0;
    }

    return create(_subclass_, objpath, pos, rot);
}

#pragma warning(push)
#pragma warning(disable : 4191)

inline ot::EObjectType vehicle::type() const
{ return VT_CALL(ot::EObjectType,() const,1)(); }

inline uint vehicle::id() const
{ return VT_CALL(uint,() const,2)(); }

inline void* vehicle::get_custom_data() const
{ return VT_CALL(void*,() const,3)(); }

inline void vehicle::set_custom_data( void* p )
{ return VT_CALL(void,(void*),4)(p); }

inline uint vehicle::get_editor_id() const
{ return VT_CALL(uint,() const,5)(); }

inline void vehicle::set_editor_id( uint id )
{ return VT_CALL(void,(uint),6)(id); }

inline void vehicle::set_collision_group( uint group, uint mask )
{ return VT_CALL(void,(uint,uint),7)(group,mask); }

inline uint vehicle::get_collision_group( uint* mask ) const
{ return VT_CALL(uint,(uint*) const,8)(mask); }

inline void* vehicle::get_pkg_geomob() const
{ return VT_CALL(void*,() const,9)(); }

inline coid::token vehicle::get_objurl() const
{ return VT_CALL(coid::token,() const,10)(); }

inline bool vehicle::get_objdef_info( ot::pkginfo::objdef& info ) const
{ return VT_CALL(bool,(ot::pkginfo::objdef&) const,11)(info); }

inline const ot::vehicle_params& vehicle::vehicle_params() const
{ return VT_CALL(const ot::vehicle_params&,() const,12)(); }

inline const double3& vehicle::get_pos() const
{ return VT_CALL(const double3&,() const,13)(); }

inline void vehicle::set_pos( const double3& pos, bool commit )
{ return VT_CALL(void,(const double3&,bool),14)(pos,commit); }

inline const quat& vehicle::get_rot() const
{ return VT_CALL(const quat&,() const,15)(); }

inline void vehicle::set_rot( const quat& rot )
{ return VT_CALL(void,(const quat&),16)(rot); }

inline void vehicle::set_pos_rot( const double3& pos, const quat& rot )
{ return VT_CALL(void,(const double3&,const quat&),17)(pos,rot); }

inline int vehicle::get_positional_data( ot::dynamic_pos& data ) const
{ return VT_CALL(int,(ot::dynamic_pos&) const,18)(data); }

inline int vehicle::set_positional_data( const ot::dynamic_pos& data )
{ return VT_CALL(int,(const ot::dynamic_pos&),19)(data); }

inline void vehicle::commit()
{ return VT_CALL(void,(),20)(); }

inline void vehicle::set_fps_camera( const float3& pos, const quat& rot, bool head_sim, bool cam_enabled, uint joint_id )
{ return VT_CALL(void,(const float3&,const quat&,bool,bool,uint),21)(pos,rot,head_sim,cam_enabled,joint_id); }

inline float3 vehicle::get_fps_camera_pos() const
{ return VT_CALL(float3,() const,22)(); }

inline float3 vehicle::heading_pitch_roll() const
{ return VT_CALL(float3,() const,23)(); }

inline void vehicle::velocity( bool model_space, float3& linear, float3& angular ) const
{ return VT_CALL(void,(bool,float3&,float3&) const,24)(model_space,linear,angular); }

inline iref<ot::geomob> vehicle::get_geomob( int id )
{ return VT_CALL(iref<ot::geomob>,(int),25)(id); }

inline void vehicle::start_engine()
{ return VT_CALL(void,(),26)(); }

inline void vehicle::stop_engine()
{ return VT_CALL(void,(),27)(); }

inline ot::ECameraMode vehicle::enter( ot::ECameraMode camode, ot::EControlsBinding bindio )
{ return VT_CALL(ot::ECameraMode,(ot::ECameraMode,ot::EControlsBinding),28)(camode,bindio); }

inline void vehicle::exit()
{ return VT_CALL(void,(),29)(); }

inline ot::ECameraMode vehicle::get_camera_mode() const
{ return VT_CALL(ot::ECameraMode,() const,30)(); }

inline void vehicle::fetch_controls( coid::dynarray<int32>& buf, bool append )
{ return VT_CALL(void,(coid::dynarray<int32>&,bool),31)(buf,append); }

inline void vehicle::apply_controls( const int32* cmd, uint ncmds )
{ return VT_CALL(void,(const int32*,uint),32)(cmd,ncmds); }

inline void vehicle::extra_force( const float3& mpos, const float3& force, bool worldspace )
{ return VT_CALL(void,(const float3&,const float3&,bool),33)(mpos,force,worldspace); }

inline void vehicle::extra_impulse( const float3& mpos, const float3& impulse, bool worldspace )
{ return VT_CALL(void,(const float3&,const float3&,bool),34)(mpos,impulse,worldspace); }

inline float3 vehicle::com_offset() const
{ return VT_CALL(float3,() const,35)(); }

inline btCollisionObject* vehicle::collision_object() const
{ return VT_CALL(btCollisionObject*,() const,36)(); }

inline void vehicle::get_wheels_data( coid::dynarray<ot::wheel_data>& wda ) const
{ return VT_CALL(void,(coid::dynarray<ot::wheel_data>&) const,37)(wda); }

inline void vehicle::set_wheels_data( const coid::dynarray<ot::wheel_data>& wda )
{ return VT_CALL(void,(const coid::dynarray<ot::wheel_data>&),38)(wda); }

inline void vehicle::pause( bool p )
{ return VT_CALL(void,(bool),39)(p); }

inline void vehicle::open( int openid, ushort modifiers )
{ return VT_CALL(void,(int,ushort),40)(openid,modifiers); }

inline void vehicle::remove_from_scene()
{ return VT_CALL(void,(),41)(); }

inline void vehicle::set_visible( bool visible )
{ return VT_CALL(void,(bool),42)(visible); }

inline bool vehicle::is_visible() const
{ return VT_CALL(bool,() const,43)(); }

inline bool vehicle::is_ready() const
{ return VT_CALL(bool,() const,44)(); }

inline bool vehicle::is_persistent() const
{ return VT_CALL(bool,() const,45)(); }

inline bool vehicle::is_script_error() const
{ return VT_CALL(bool,() const,46)(); }

inline void vehicle::set_inputs( float engine, float brake, float steering, float parking_brake )
{ return VT_CALL(void,(float,float,float,float),47)(engine,brake,steering,parking_brake); }

inline bool vehicle::set_ext_param( const coid::token& name, float value )
{ return VT_CALL(bool,(const coid::token&,float),48)(name,value); }

inline bool vehicle::get_ext_param( const coid::token& name, float& value )
{ return VT_CALL(bool,(const coid::token&,float&),49)(name,value); }

inline iref<ot::vehicle_physics> vehicle::physics_interface() const
{ return VT_CALL(iref<ot::vehicle_physics>,() const,50)(); }

#pragma warning(pop)

} //namespace

#endif //__INTERGEN_GENERATED__vehicle_H__
