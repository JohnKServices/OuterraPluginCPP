
//@file  javascript interface dispatcher generated by intergen v7
//See LICENSE file for copyright and license information

#include <comm/metastream/metastream.h>
#include <comm/binstream/filestream.h>
#include <comm/binstream/binstreambuf.h>


#include "ifc/engine.jsc.h"

using namespace coid;

////////////////////////////////////////////////////////////////////////////////
//
// javascript handler of interface engine of class simplugin
//
////////////////////////////////////////////////////////////////////////////////

namespace xt {
namespace js {

////////////////////////////////////////////////////////////////////////////////
///Interface declaration: [namespace::]name, path
class engine_js_dispatcher
    : public ::jsc::interface_wrapper_base<xt::engine>
{
    bool _own_context = false;
    bool _is_weak = false;

    static void _finalizer(JSObjectRef obj)
    {
        jsc::ifc_private_data* p = static_cast<jsc::ifc_private_data*>(JSObjectGetPrivate(obj));
        engine_js_dispatcher* ifc = static_cast<engine_js_dispatcher*>(p->that);
        if(ifc->_is_weak) {
            jsc::jsc_queue_finalize(p, [](void* ptr){
                engine_js_dispatcher* ifc = static_cast<engine_js_dispatcher*>(ptr);
                ifc->_object = nullptr;
                ifc->release_refcount();
            });
        }
        delete p;
    }
protected:

    EBackend intergen_backend() const override { return IFC_BACKEND_JS; }

public:

    JSObjectRef create_interface_object( JSContextRef context, bool make_weak );

    static void load_script( const coid::token& scriptfile, const coid::token& file_name, JSContextRef ctx);

    COIDNEWDELETE("xt::engine_js_dispatcher");

    engine_js_dispatcher()
    {}

    explicit engine_js_dispatcher( xt::engine* orig ) {
        _base.create(orig);
        _vtable = _base->vtable();
		_host = _base->host<policy_intrusive_base>();
    }

    void set_host( policy_intrusive_base* host ) {
        _host = host;
    }

    ~engine_js_dispatcher() {
        if (!_is_weak && _object) {
            JSValueUnprotect(_context, _object);
        }
        if (_own_context) {
            JSGlobalContextRelease(JSContextGetGlobalContext(_context));
        }
        _object = nullptr;
        _context = nullptr;
    }

    bool is_weak() const { return _is_weak; }

    bool intergen_bind_capture( coid::binstring* capture, uint instid ) override
    {
        return _real()->intergen_bind_capture(capture, instid);
    }

    void intergen_capture_dispatch( uint mid, coid::binstring& bin ) override
    {
        _real()->intergen_capture_dispatch(mid, bin);
    }

    // --- creators ---

    ///Interface creator
    static iref<engine_js_dispatcher> get( const jsc::script_handle& scriptpath, const coid::token& bindname, JSContextRef* );

    static JSValueRef jsc_creator_get0(JSContextRef ctx, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], interface_context* ifc, JSValueRef* exception);

    ///Handler for generic $query_interface javascript method
    static JSValueRef jsc_query_interface(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception);
    static JSValueRef jsc_query_interface_global(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception);
    static JSValueRef jsc_log(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception);
    static JSValueRef jsc_rebind_events(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception);
    static JSValueRef jsc_current_global(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception);

    // --- method wrappers ---

	static JSValueRef jsc_set_value0(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception);
	static JSValueRef jsc_init_chassis1(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception);
	static JSValueRef jsc_init_vehicle2(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception);
	static JSValueRef jsc_update_vehicle3(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception);
	static JSValueRef jsc_firething4(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception);
	static JSValueRef jsc_turretthing5(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception);
	static JSValueRef jsc_mantletthing6(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception);
	static JSValueRef jsc_get_value7(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception);
};


////////////////////////////////////////////////////////////////////////////////
JSValueRef engine_js_dispatcher::jsc_set_value0(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception)
{
    if (argumentCount < 1 || argumentCount > 1) { //in/inout arguments
        const char* tmp = "Wrong number of arguments in engine.set_value";
        *exception = jsc::throw_js(ctx, tmp);
        return JSValueMakeUndefined(ctx);
    }
    if (!thisObject)
        return JSValueMakeUndefined(ctx);
	jsc::ifc_private_data* p = static_cast<jsc::ifc_private_data*>(JSObjectGetPrivate(thisObject));
    if (!p)
        return JSValueMakeUndefined(ctx);

    ::jsc::interface_wrapper_base<xt::engine>* ifc = static_cast<::jsc::interface_wrapper_base<xt::engine>*>
        (p->that);

    auto R_ = ifc ? ifc->_real() : 0;
    if (!R_) {
        const char* tmp = "Null interface object in engine.set_value";
        *exception = jsc::throw_js(ctx, tmp);
        return JSValueMakeUndefined(ctx);
    }

    try {
        //stream the arguments in
        static_assert(CHECK::meta_operator_exists<int>::value, "missing metastream operator 'int'");

        threadcached<int> x;
        write_from_jsc(ctx, arguments[0], x);

        //invoke
        R_->set_value(x);

        //stream out
        JSValueRef r__ = JSValueMakeUndefined(ctx);

        return r__;
    } catch(const coid::exception& e) {
        *exception = jsc::throw_js(ctx, e.text());
        return JSValueMakeUndefined(ctx);
    }
}

////////////////////////////////////////////////////////////////////////////////
JSValueRef engine_js_dispatcher::jsc_init_chassis1(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception)
{
    if (argumentCount < 1 || argumentCount > 1) { //in/inout arguments
        const char* tmp = "Wrong number of arguments in engine.init_chassis";
        *exception = jsc::throw_js(ctx, tmp);
        return JSValueMakeUndefined(ctx);
    }
    if (!thisObject)
        return JSValueMakeUndefined(ctx);
	jsc::ifc_private_data* p = static_cast<jsc::ifc_private_data*>(JSObjectGetPrivate(thisObject));
    if (!p)
        return JSValueMakeUndefined(ctx);

    ::jsc::interface_wrapper_base<xt::engine>* ifc = static_cast<::jsc::interface_wrapper_base<xt::engine>*>
        (p->that);

    auto R_ = ifc ? ifc->_real() : 0;
    if (!R_) {
        const char* tmp = "Null interface object in engine.init_chassis";
        *exception = jsc::throw_js(ctx, tmp);
        return JSValueMakeUndefined(ctx);
    }

    try {
        //stream the arguments in

        threadcached<iref<ot::vehicle_physics>> obj;
        write_from_jsc(ctx, arguments[0], obj);

        //invoke
        R_->init_chassis(obj);

        //stream out
        JSValueRef r__ = JSValueMakeUndefined(ctx);

        return r__;
    } catch(const coid::exception& e) {
        *exception = jsc::throw_js(ctx, e.text());
        return JSValueMakeUndefined(ctx);
    }
}

////////////////////////////////////////////////////////////////////////////////
JSValueRef engine_js_dispatcher::jsc_init_vehicle2(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception)
{
    if (argumentCount < 1 || argumentCount > 1) { //in/inout arguments
        const char* tmp = "Wrong number of arguments in engine.init_vehicle";
        *exception = jsc::throw_js(ctx, tmp);
        return JSValueMakeUndefined(ctx);
    }
    if (!thisObject)
        return JSValueMakeUndefined(ctx);
	jsc::ifc_private_data* p = static_cast<jsc::ifc_private_data*>(JSObjectGetPrivate(thisObject));
    if (!p)
        return JSValueMakeUndefined(ctx);

    ::jsc::interface_wrapper_base<xt::engine>* ifc = static_cast<::jsc::interface_wrapper_base<xt::engine>*>
        (p->that);

    auto R_ = ifc ? ifc->_real() : 0;
    if (!R_) {
        const char* tmp = "Null interface object in engine.init_vehicle";
        *exception = jsc::throw_js(ctx, tmp);
        return JSValueMakeUndefined(ctx);
    }

    try {
        //stream the arguments in

        threadcached<iref<ot::vehicle_physics>> obj;
        write_from_jsc(ctx, arguments[0], obj);

        //invoke
        R_->init_vehicle(obj);

        //stream out
        JSValueRef r__ = JSValueMakeUndefined(ctx);

        return r__;
    } catch(const coid::exception& e) {
        *exception = jsc::throw_js(ctx, e.text());
        return JSValueMakeUndefined(ctx);
    }
}

////////////////////////////////////////////////////////////////////////////////
JSValueRef engine_js_dispatcher::jsc_update_vehicle3(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception)
{
    if (argumentCount < 4 || argumentCount > 4) { //in/inout arguments
        const char* tmp = "Wrong number of arguments in engine.update_vehicle";
        *exception = jsc::throw_js(ctx, tmp);
        return JSValueMakeUndefined(ctx);
    }
    if (!thisObject)
        return JSValueMakeUndefined(ctx);
	jsc::ifc_private_data* p = static_cast<jsc::ifc_private_data*>(JSObjectGetPrivate(thisObject));
    if (!p)
        return JSValueMakeUndefined(ctx);

    ::jsc::interface_wrapper_base<xt::engine>* ifc = static_cast<::jsc::interface_wrapper_base<xt::engine>*>
        (p->that);

    auto R_ = ifc ? ifc->_real() : 0;
    if (!R_) {
        const char* tmp = "Null interface object in engine.update_vehicle";
        *exception = jsc::throw_js(ctx, tmp);
        return JSValueMakeUndefined(ctx);
    }

    try {
        //stream the arguments in
        static_assert(CHECK::meta_operator_exists<float>::value, "missing metastream operator 'float'");
        static_assert(CHECK::meta_operator_exists<float>::value, "missing metastream operator 'float'");
        static_assert(CHECK::meta_operator_exists<float>::value, "missing metastream operator 'float'");
        static_assert(CHECK::meta_operator_exists<float>::value, "missing metastream operator 'float'");

        threadcached<float> dt;
        write_from_jsc(ctx, arguments[0], dt);

        threadcached<float> throttle;
        write_from_jsc(ctx, arguments[1], throttle);

        threadcached<float> brake;
        write_from_jsc(ctx, arguments[2], brake);

        threadcached<float> steer;
        write_from_jsc(ctx, arguments[3], steer);

        //invoke
        R_->update_vehicle(dt, throttle, brake, steer);

        //stream out
        JSValueRef r__ = JSValueMakeUndefined(ctx);

        return r__;
    } catch(const coid::exception& e) {
        *exception = jsc::throw_js(ctx, e.text());
        return JSValueMakeUndefined(ctx);
    }
}

////////////////////////////////////////////////////////////////////////////////
JSValueRef engine_js_dispatcher::jsc_firething4(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception)
{
    if (argumentCount < 0 || argumentCount > 0) { //in/inout arguments
        const char* tmp = "Wrong number of arguments in engine.firething";
        *exception = jsc::throw_js(ctx, tmp);
        return JSValueMakeUndefined(ctx);
    }
    if (!thisObject)
        return JSValueMakeUndefined(ctx);
	jsc::ifc_private_data* p = static_cast<jsc::ifc_private_data*>(JSObjectGetPrivate(thisObject));
    if (!p)
        return JSValueMakeUndefined(ctx);

    ::jsc::interface_wrapper_base<xt::engine>* ifc = static_cast<::jsc::interface_wrapper_base<xt::engine>*>
        (p->that);

    auto R_ = ifc ? ifc->_real() : 0;
    if (!R_) {
        const char* tmp = "Null interface object in engine.firething";
        *exception = jsc::throw_js(ctx, tmp);
        return JSValueMakeUndefined(ctx);
    }

    try {
        //stream the arguments in

        //invoke
        R_->firething();

        //stream out
        JSValueRef r__ = JSValueMakeUndefined(ctx);

        return r__;
    } catch(const coid::exception& e) {
        *exception = jsc::throw_js(ctx, e.text());
        return JSValueMakeUndefined(ctx);
    }
}

////////////////////////////////////////////////////////////////////////////////
JSValueRef engine_js_dispatcher::jsc_turretthing5(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception)
{
    if (argumentCount < 2 || argumentCount > 2) { //in/inout arguments
        const char* tmp = "Wrong number of arguments in engine.turretthing";
        *exception = jsc::throw_js(ctx, tmp);
        return JSValueMakeUndefined(ctx);
    }
    if (!thisObject)
        return JSValueMakeUndefined(ctx);
	jsc::ifc_private_data* p = static_cast<jsc::ifc_private_data*>(JSObjectGetPrivate(thisObject));
    if (!p)
        return JSValueMakeUndefined(ctx);

    ::jsc::interface_wrapper_base<xt::engine>* ifc = static_cast<::jsc::interface_wrapper_base<xt::engine>*>
        (p->that);

    auto R_ = ifc ? ifc->_real() : 0;
    if (!R_) {
        const char* tmp = "Null interface object in engine.turretthing";
        *exception = jsc::throw_js(ctx, tmp);
        return JSValueMakeUndefined(ctx);
    }

    try {
        //stream the arguments in
        static_assert(CHECK::meta_operator_exists<float>::value, "missing metastream operator 'float'");
        static_assert(CHECK::meta_operator_exists<float>::value, "missing metastream operator 'float'");

        threadcached<float> v;
        write_from_jsc(ctx, arguments[0], v);

        threadcached<float> dt;
        write_from_jsc(ctx, arguments[1], dt);

        //invoke
        R_->turretthing(v, dt);

        //stream out
        JSValueRef r__ = JSValueMakeUndefined(ctx);

        return r__;
    } catch(const coid::exception& e) {
        *exception = jsc::throw_js(ctx, e.text());
        return JSValueMakeUndefined(ctx);
    }
}

////////////////////////////////////////////////////////////////////////////////
JSValueRef engine_js_dispatcher::jsc_mantletthing6(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception)
{
    if (argumentCount < 2 || argumentCount > 2) { //in/inout arguments
        const char* tmp = "Wrong number of arguments in engine.mantletthing";
        *exception = jsc::throw_js(ctx, tmp);
        return JSValueMakeUndefined(ctx);
    }
    if (!thisObject)
        return JSValueMakeUndefined(ctx);
	jsc::ifc_private_data* p = static_cast<jsc::ifc_private_data*>(JSObjectGetPrivate(thisObject));
    if (!p)
        return JSValueMakeUndefined(ctx);

    ::jsc::interface_wrapper_base<xt::engine>* ifc = static_cast<::jsc::interface_wrapper_base<xt::engine>*>
        (p->that);

    auto R_ = ifc ? ifc->_real() : 0;
    if (!R_) {
        const char* tmp = "Null interface object in engine.mantletthing";
        *exception = jsc::throw_js(ctx, tmp);
        return JSValueMakeUndefined(ctx);
    }

    try {
        //stream the arguments in
        static_assert(CHECK::meta_operator_exists<float>::value, "missing metastream operator 'float'");
        static_assert(CHECK::meta_operator_exists<float>::value, "missing metastream operator 'float'");

        threadcached<float> v;
        write_from_jsc(ctx, arguments[0], v);

        threadcached<float> dt;
        write_from_jsc(ctx, arguments[1], dt);

        //invoke
        R_->mantletthing(v, dt);

        //stream out
        JSValueRef r__ = JSValueMakeUndefined(ctx);

        return r__;
    } catch(const coid::exception& e) {
        *exception = jsc::throw_js(ctx, e.text());
        return JSValueMakeUndefined(ctx);
    }
}

////////////////////////////////////////////////////////////////////////////////
JSValueRef engine_js_dispatcher::jsc_get_value7(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception)
{
    if (argumentCount < 0 || argumentCount > 0) { //in/inout arguments
        const char* tmp = "Wrong number of arguments in engine.get_value";
        *exception = jsc::throw_js(ctx, tmp);
        return JSValueMakeUndefined(ctx);
    }
    if (!thisObject)
        return JSValueMakeUndefined(ctx);
	jsc::ifc_private_data* p = static_cast<jsc::ifc_private_data*>(JSObjectGetPrivate(thisObject));
    if (!p)
        return JSValueMakeUndefined(ctx);

    ::jsc::interface_wrapper_base<xt::engine>* ifc = static_cast<::jsc::interface_wrapper_base<xt::engine>*>
        (p->that);

    auto R_ = ifc ? ifc->_real() : 0;
    if (!R_) {
        const char* tmp = "Null interface object in engine.get_value";
        *exception = jsc::throw_js(ctx, tmp);
        return JSValueMakeUndefined(ctx);
    }

    try {
        //stream the arguments in

        //invoke
        int _rval_ = R_->get_value();

        //stream out
        JSValueRef r__ = nullptr;
        static_assert( CHECK::meta_operator_exists<int>::value, "missing metastream operator for 'int'" );
        r__ = read_to_jsc(ctx, _rval_);

        return r__;
    } catch(const coid::exception& e) {
        *exception = jsc::throw_js(ctx, e.text());
        return JSValueMakeUndefined(ctx);
    }
}



////////////////////////////////////////////////////////////////////////////////
JSValueRef engine_js_dispatcher::jsc_log(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception)
{
    if (argumentCount == 0)
        return JSValueMakeUndefined(ctx);

    const void* inst = 0;

    if (thisObject) {
        jsc::ifc_private_data* ptr = static_cast<jsc::ifc_private_data*>(JSObjectGetPrivate(thisObject));
        if (ptr) {
            xt::js::engine_js_dispatcher* ifc = static_cast<xt::js::engine_js_dispatcher*>(ptr->that);
            inst = ifc;
            if (!ifc) {
                *exception = jsc::throw_js(ctx, "Null interface object in $log");
                return JSValueMakeUndefined(ctx);
            }
        }
    }

    JSStringRef s = JSValueToStringCopy(ctx, arguments[0], 0);
	charstr buf = jsc::to_charstr(s);
    JSStringRelease(s);

    coid::token tokey(buf);

    intergen_interface::ifclog_ext(coid::log::none, coid::tokenhash("xt::engine"),
        inst, tokey);

    return JSValueMakeUndefined(ctx);
}

////////////////////////////////////////////////////////////////////////////////
JSValueRef engine_js_dispatcher::jsc_query_interface(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception)
{
    if (argumentCount < 1) {
        *exception = jsc::throw_js(ctx, "Interface creator name missing");
        return JSValueMakeUndefined(ctx);
    }

	JSStringRef s = JSValueToStringCopy(ctx, arguments[0], exception);
	if (*exception) return JSValueMakeUndefined(ctx);
    charstr key = jsc::to_charstr(s);
    JSStringRelease(s);
    
    typedef JSValueRef (*fn_get)(JSContextRef, JSObjectRef, size_t, const JSValueRef[], interface_context*, JSValueRef*);
    fn_get get = reinterpret_cast<fn_get>(
        coid::interface_register::get_interface_creator(key));
        
    if (!get) {
        coid::charstr tmp = "interface creator ";
        tmp << key << " not found";
        *exception = jsc::throw_js(ctx, tmp);
        return JSValueMakeUndefined(ctx);
    }

    if (!thisObject)
        return JSValueMakeUndefined(ctx);
    jsc::ifc_private_data* ptr = static_cast<jsc::ifc_private_data*>(JSObjectGetPrivate(thisObject));
    if (!ptr)
        return JSValueMakeUndefined(ctx);
    
    xt::js::engine_js_dispatcher* ifc = static_cast<xt::js::engine_js_dispatcher*>(ptr->that);

    if (!ifc) {
        *exception = jsc::throw_js(ctx, "Null interface object in $query_interface");
        return JSValueMakeUndefined(ctx);
    }

    return get(ctx, thisObject, argumentCount, arguments, ifc, exception);
}

////////////////////////////////////////////////////////////////////////////////
JSValueRef engine_js_dispatcher::jsc_query_interface_global(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception)
{
    if (argumentCount < 1) {
        *exception = jsc::throw_js(ctx, "Interface creator name missing");
        return JSValueMakeUndefined(ctx);
    }

    typedef JSValueRef (*fn_get)(JSContextRef, JSObjectRef, size_t, const JSValueRef[], interface_context*, JSValueRef*);
	
	JSStringRef s = JSValueToStringCopy(ctx, arguments[0], nullptr);
	charstr buf = jsc::to_charstr(s);
    JSStringRelease(s);
    fn_get get = reinterpret_cast<fn_get>(coid::interface_register::get_interface_creator(buf));

    if (!get) {
        coid::charstr tmp = "interface creator ";
        tmp << buf << " not found";
        *exception = jsc::throw_js(ctx, tmp);
        return JSValueMakeUndefined(ctx);
    }
	
	return get(ctx, thisObject, argumentCount, arguments, 0, exception);
}

////////////////////////////////////////////////////////////////////////////////
JSValueRef engine_js_dispatcher::jsc_rebind_events(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception)
{
    return JSValueMakeUndefined(ctx);
}

////////////////////////////////////////////////////////////////////////////////
JSValueRef engine_js_dispatcher::jsc_current_global(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception)
{
    if (!thisObject)
        return JSValueMakeUndefined(ctx);
    jsc::ifc_private_data* ptr = static_cast<jsc::ifc_private_data*>(JSObjectGetPrivate(thisObject));
    if (!ptr)
        return JSValueMakeUndefined(ctx);

    xt::js::engine_js_dispatcher* ifc = static_cast<xt::js::engine_js_dispatcher*>(ptr->that);
    JSObjectRef g = JSContextGetGlobalObject(ctx);
    JSValueRef prototype = JSObjectGetPrototype(ctx, g);
    return prototype;
}


////////////////////////////////////////////////////////////////////////////////
JSObjectRef engine_js_dispatcher::create_interface_object( JSContextRef context, bool make_weak )
{
    _is_weak = make_weak;
	
	static JSClassRef cls = nullptr;
	if (!cls) {
		JSClassDefinition def = kJSClassDefinitionEmpty;
		const JSStaticFunction funcs[] = {
			{ "$query_interface", &jsc_query_interface, 0 },
            { "$rebind_events", &jsc_rebind_events, 0 },
            { "$log", &jsc_log, 0 },
            { "$ctx", &jsc_current_global, 0 },
			{ "set_value", &jsc_set_value0, 0 },
			{ "init_chassis", &jsc_init_chassis1, 0 },
			{ "init_vehicle", &jsc_init_vehicle2, 0 },
			{ "update_vehicle", &jsc_update_vehicle3, 0 },
			{ "firething", &jsc_firething4, 0 },
			{ "turretthing", &jsc_turretthing5, 0 },
			{ "mantletthing", &jsc_mantletthing6, 0 },
			{ "get_value", &jsc_get_value7, 0 },
			{ nullptr, nullptr, 0 },
		};
		def.staticFunctions = funcs;
        def.finalize = _finalizer;
		cls = JSClassCreate(&def);
    }
	
    jsc::ifc_private_data* p = new jsc::ifc_private_data;
    p->that = this;
    p->hash = 3109209806;
	JSObjectRef obj = JSObjectMake(context, cls, p);

    if (make_weak) {
        add_refcount();
    }
    else {
        JSValueProtect(context, obj);
    }

    return obj;
}

// --- creators ---

////////////////////////////////////////////////////////////////////////////////
iref<engine_js_dispatcher> engine_js_dispatcher::get( const jsc::script_handle& script, const coid::token& bindname, JSContextRef* ctx )
{
    JSContextRef context = nullptr;

    // create interface object
    iref<engine_js_dispatcher> ifc = xt::engine::get(new engine_js_dispatcher);
    if (!ifc)
        throw coid::exception() << "failed to create interface object";

    // check if an external context provider is required
    if (script.is_path()) {
        coid::token path = script.str();
        path.cut_right('?', coid::token::cut_trait_remove_sep_default_empty());

        bool ispage = path.begins_with("http://") || path.begins_with("https://") || path.ends_with(".html");
        bool isscript = path.ends_with(".js");

        if (ispage && !isscript) {
            typedef JSContextRef (*fn_getctx)(const coid::token&, policy_intrusive_base*);

            fn_getctx ctxgetter = reinterpret_cast<fn_getctx>(
                    coid::interface_register::get_interface_creator("~html@system_context_getter2"));

            if (!ctxgetter)
                throw coid::exception() << "unable to acquire the system context creator interface";

            context = ctxgetter(script.str(), ifc.get());
            if (!context)
                throw coid::exception() << "unable to create context";
        }
    }

    bool extctx = context;

    ifc->_own_context = false;
    if (!extctx) {
        if (script.has_context())
            context = script.context();
        else {
            context = JSGlobalContextCreateInGroup(jsc::jsc_get_current_group(), 0);
            ifc->_own_context = true;
        }
    }

    //set early here as sometimes the invoked creator methods want to access it
    if (ctx)
        *ctx = context;

    ifc->_context = context;

	JSObjectRef global = JSContextGetGlobalObject(context);
    if (!extctx && !script.is_context())
    {
        if (!script.has_context()) {
            jsc::set_property(context, global, "$include", &jsc::script_handle::js_include);
            jsc::set_property(context, global, "$query_interface", &engine_js_dispatcher::jsc_query_interface_global);
            jsc::set_property(context, global, "$log", &engine_js_dispatcher::jsc_log);
        }

        coid::token script_tok;
        coid::charstr script_tmp;
        if (script.is_path()) {
            coid::bifstream bif (script.str());
            if (!bif.is_open())
                throw coid::exception() << script.str() << " not found";

            script_tmp = script.prefix();

            coid::binstreambuf buf;
            buf.swap(script_tmp);
            buf.transfer_from(bif);
            buf.swap(script_tmp);

            script_tok = script_tmp;
        }
        else if (script.prefix()) {
            script_tmp << script.prefix() << script.str();
            script_tok = script_tmp;
        }
        else {
            script_tok = script.str();
        }

		ifc->_object = ifc->create_interface_object(context, false);

        if (bindname) {
            zstring buf = bindname;
            jsc::set_property(context, global, buf.c_str(), ifc->_object);
        }

        zstring src = script_tok;
       	JSStringRef js_src = JSStringCreateWithUTF8CString(src.c_str());
        JSValueRef exc = nullptr;
	    JSEvaluateScript(context, js_src, 0, 0, 0, &exc);
        if (exc)
            jsc::script_handle::throw_js_error(context, exc);

        JSStringRelease(js_src);
    }
    else {
		ifc->_object = ifc->create_interface_object(context, false);

        if (bindname) {
            zstring buf = bindname;
            jsc::set_property(context, global, buf.c_str(), ifc->_object);
        }
    }

	return ifc;
}

////////////////////////////////////////////////////////////////////////////////
///Creator methods for access from JS
JSValueRef engine_js_dispatcher::jsc_creator_get0(JSContextRef ctx, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], interface_context* ifc, JSValueRef* exception)
{
    if (argumentCount < 1+0 || argumentCount > 1+0) { //fnc name + in/inout arguments
        const char* tmp = "Wrong number of arguments in get";
        *exception = jsc::throw_js(ctx, tmp);
        return JSValueMakeUndefined(ctx);
    }

    //stream the arguments in
    //invoke
    iref<engine_js_dispatcher> nifc = xt::engine::get(new engine_js_dispatcher);
    
    //stream out
    JSValueRef r__ = nifc
        ? nifc->create_interface_object(ctx, true)
        : JSValueMakeNull(ctx);
    
	return r__;
}

////////////////////////////////////////////////////////////////////////////////
///Create JS wrapper from an existing interface object
JSValueRef create_wrapper_engine( ::xt::engine* orig, JSContextRef context )
{
    // check that the orig points to an object
    if (!orig) return JSValueMakeNull(context);

    iref<xt::js::engine_js_dispatcher> ifc;
    JSObjectRef obj = nullptr;

    if (orig->intergen_backend() == intergen_interface::IFC_BACKEND_JS) {
        auto jsd = static_cast<engine_js_dispatcher*>(orig);
        if(jsd->is_weak()) {
            obj = jsd->_object;
        }
    }

    if (!obj) {
        // create interface object
        ifc.create(new xt::js::engine_js_dispatcher(static_cast<::xt::engine*>(orig)));

        obj = ifc->create_interface_object(context, true);
    }

    return obj;
}


////////////////////////////////////////////////////////////////////////////////
///Create JS interface from a host
static iref<xt::js::engine_js_dispatcher> create_maker_engine( policy_intrusive_base* host, JSContextRef context )
{
    // check that the orig points to an object
    if (!host)
        return 0;

    // create interface object
    iref<xt::js::engine_js_dispatcher> ifc;

    ifc.create(new xt::js::engine_js_dispatcher);
    ifc->set_host(host);

    ifc->create_interface_object(context, false);

    return ifc;
}
////////////////////////////////////////////////////////////////////////////////
static void register_binders_for_engine( bool on )
{
    //c++ creator of JS interface object
    interface_register::register_interface_creator(
        "xt::engine.get@creator.js",
        on ? (void*)&engine_js_dispatcher::get : nullptr);

    //creator from script
    interface_register::register_interface_creator(
        "xt::js::engine.get",
        on ? (void*)&engine_js_dispatcher::jsc_creator_get0 : nullptr);

    //wrapper interface creator from existing c++ interface
    interface_register::register_interface_creator(
        "xt::engine@wrapper.js",
        on ? (void*)&create_wrapper_engine : nullptr);

    //js interface creator from host
    interface_register::register_interface_creator(
        "xt::engine@maker.js",
        on ? (void*)&create_maker_engine : nullptr);        
}


//auto-register the bind function
LOCAL_SINGLETON_DEF(ifc_autoregger) engine_autoregger = new ifc_autoregger(&register_binders_for_engine);


void* force_register_engine() {
    LOCAL_SINGLETON_DEF(ifc_autoregger) autoregger = new ifc_autoregger(&register_binders_for_engine);
    return autoregger.get();
}

} //namespace js
} //namespace xt

